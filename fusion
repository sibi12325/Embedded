#include <TFT_eSPI.h>
#include <SPI.h>

// Input pins
#define SELECT_BUTTON 0
#define UP_BUTTON 16
#define DOWN_BUTTON 17

// TETRIS DEGINITIONS
//---------------------------------------------------------------------------

// Block declaration 3d array of type [block colour][pixel length][pixel width]
uint16_t BlockImage[8][12][12];

// The background
uint16_t backBuffer[220][110];

// To store the coordinates of the blocks
struct Point 
{
  int X;
  int Y;
};

// The blocks themselves (their shape, total number of rotations, and colour)
struct Block 
{
  Point square[4][4]; 
  int numRotate; 
  int colour;
};

// The current block that is falling and its position
Point pos; 
Block block;

int rot, fall_cnt = 0;

bool started, gameover = false;

bool but_ROTATE, but_LEFT, but_RIGHT, but_RESET = false;

int game_speed = 20;

// Every shape and orientation
#define UP_Z {{0,-1},{0,0},{-1,0},{-1,1}}
#define NORMAL_Z { {-1,0},{0,0},{0,1},{1,1} }

#define REVERSED_NORMAL_Z {{-1,1},{0,1},{0,0},{1,0}}
#define REVERSED_UP_Z {{0,-1},{0,0},{1,0},{1,1}}

#define RIGHT_L { {-1,-1},{-1,0},{0,0},{1,0} }
#define UPSIDEDOWN_L { {-1,1},{0,1},{0,0},{0,-1} }
#define LEFT_L { {-1,0},{0,0},{1,0},{1,1} }
#define NORMAL_L { {1,-1},{0,-1},{0,0},{0,1} }

#define REVERSED_LEFT_L {{-1,0},{0,0},{1,0},{1,-1}}
#define REVERSED_NORMAL_L {{-1,-1},{0,-1},{0,0},{0,1}}
#define REVERSED_RIGHT_L {{-1,1},{-1,0},{0,0},{1,0}}
#define REVERSED_UPSIDEDOWN_L {{0,-1},{0,0},{0,1},{1,1}}

#define UPSIDEDOWN_WASD {{-1,0},{0,0},{1,0},{0,-1}}
#define LEFT_WASD {{0,-1},{0,0},{0,1},{-1,0}}
#define NORMAL_WASD {{-1,0},{0,0},{1,0},{0,1}}
#define RIGHT_WASD {{0,-1},{0,0},{0,1},{1,0}}


#define SQUARE { {0,-1},{1,-1},{0,0},{1,0} }

#define HORIZONTAL_LINE { {-1,0},{0,0},{1,0},{2,0} }
#define VERTICAL_LINE { {0,-1},{0,0},{0,1},{0,2} }

#define EMPTY { {0,0},{0,0},{0,0},{0,0} }

// Array storing all the shapes and orientation
Block blocks[7] = {
  {
    {  HORIZONTAL_LINE, VERTICAL_LINE,
    EMPTY, EMPTY  }, 
    2, 
    1
  },

  {  
    {  SQUARE, EMPTY,
    EMPTY, EMPTY  },
    1,
    2
  },

  {
    {  RIGHT_L,UPSIDEDOWN_L,
    LEFT_L,NORMAL_L  },
    4,
    3
  },

  {
    { NORMAL_Z,UP_Z,
    EMPTY, EMPTY },
    2,
    4
  },

  {
    { REVERSED_LEFT_L,REVERSED_NORMAL_L,
    REVERSED_RIGHT_L,REVERSED_UPSIDEDOWN_L },
    4,
    5
  },

  {
    { REVERSED_NORMAL_Z,REVERSED_UP_Z,
    EMPTY, EMPTY },
    2,
    6
  },

  {
    { UPSIDEDOWN_WASD,LEFT_WASD,
    NORMAL_WASD,RIGHT_WASD },
    4,
    7
  }
};

extern uint8_t tetris_img[];

// Initial conditions
bool leftButtonPressed = false;
bool rightButtonPressed = false;
bool rotateButtonPressed = false;
bool resetButtonPressed = false;

bool resetted = false;

int score=0;
int lvl=1;

int leftButton=16;
int rightButton=17;
int rotateButton = 0;
int resetButton = 14;

//  Define the colours to be used
#define GREY 0x5AEB
#define RED 0x00F0
#define PURPLE 0xFBE4
#define BLUE 0xFF00
#define GREEN 0xFF87
#define YELLOW 0x87FF
#define LIGHT_GREEN 0xF00F
#define PINK 0xF8FC

// the number of pixels for a side of a block
#define Length 11

// the number of horizontal blocks
#define Width 10

// the number of vertical blocks
#define Height 20

// Initialise the screen. it shows colour-numbers of all positions
int screen[Width][Height] = {0};

//----------------------------------------------------------------

TFT_eSPI tft = TFT_eSPI();

#define totalGames 2;

bool downPressed = false;
bool upPressed = true;

int currentSelection = 0;

void setup() 
{

  tft.init();
  tft.fillScreen(TFT_BLACK);

  tft.setTextSize(2);

  // Initialize buttons
  pinMode(SELECT_BUTTON, INPUT_PULLUP);
  pinMode(UP_BUTTON, INPUT_PULLUP);
  pinMode(DOWN_BUTTON, INPUT_PULLUP);

  // Display the menu
  drawMenu();
  
}

void loop() 
{

  // Moving up the menu
  if (digitalRead(UP_BUTTON) == HIGH) 
  {
    if(!upPressed)
    {
      currentSelection = !currentSelection;
      drawMenu();
      delay(200);
    }

    upPressed = true;

  }else
  {
    upPressed = false;
  }

  // Moving down the menu
  if (digitalRead(DOWN_BUTTON) == HIGH) 
  {
    if (!downPressed)
    {
      currentSelection = !currentSelection;
      drawMenu();
      delay(200);
    }

    downPressed = true;

  }
  else
  {
    downPressed = false;
  }

  // selecting a game
  if (!digitalRead(SELECT_BUTTON) == HIGH) 
  {
    selectGame(currentSelection);
    delay(500);
  }
}

void drawMenu() 
{
  tft.fillScreen(TFT_BLACK);

  tft.setTextColor(TFT_WHITE);
  tft.drawString("Select a Game:", 10, tft.height() / 4);

  if (currentSelection == 0) 
  {
    tft.setTextColor(TFT_YELLOW);
    tft.drawString("Pong", 80, 2*tft.height() / 4);
  } 
  else 
  {
    tft.setTextColor(TFT_WHITE);
    tft.drawString("Pong", 80, 2*tft.height() / 4);
  }
  tft.setCursor(50, 110);

  if (currentSelection == 1) 
  {
    tft.setTextColor(TFT_YELLOW);
    tft.drawString("Tetris", 80, 3*tft.height() / 4);
  } 
  else 
  {
    tft.setTextColor(TFT_WHITE);
    tft.drawString("Tetris", 80, 3*tft.height() / 4);
  }
}

void selectGame(int selection) 
{
  switch (selection) 
  {
    case 0:
      runPong();
      break;

    case 1:
      runTetris();
      break;
  }
}

void runPong()
{
  // Paddle and ball settings
  int PADDLE_WIDTH = 10;
  int PADDLE_HEIGHT = 30;
  int BALL_SIZE = 8;
  int PADDLE_SPEED = 4;

  // Ball speed settings
  int INITIAL_BALL_SPEED = 3;
  int BALL_SPEED_INCREMENT = 0.2;
  int MAX_BALL_SPEED = 10;

  // Player input pins
  int PLAYER1_UP = 16;
  int PLAYER1_DOWN = 17;
  int PLAYER2_UP = 14;
  int PLAYER2_DOWN = 0;

  // direction of ball
  float ballDirX = INITIAL_BALL_SPEED, ballDirY = INITIAL_BALL_SPEED;

  // scores
  int player1Score = 0, player2Score = 0;

  // current speed
  float currentBallSpeed = INITIAL_BALL_SPEED;

  // pre check variables
  bool gameStarted = false;
  bool player1Ready = false, player2Ready = false;

  tft.init();
  tft.setRotation(1); // puts in landscape mode
  tft.fillScreen(TFT_BLACK);

  // Starting positions of the ball and paddles
  int player1Y = (tft.height() - PADDLE_HEIGHT) / 2;            
  int player2Y = (tft.height() - PADDLE_HEIGHT) / 2;
  int ballX = tft.width() / 2;
  int ballY = tft.height() / 2;

  // set up pins
  pinMode(PLAYER1_UP, INPUT_PULLUP);
  pinMode(PLAYER1_DOWN, INPUT_PULLUP);
  pinMode(PLAYER2_UP, INPUT);
  pinMode(PLAYER2_DOWN, INPUT);

  // Show waiting screen
  tft.setTextSize(2);
  tft.setTextColor(TFT_WHITE);
  String text = "Waiting for players...";
  tft.drawString(text, tft.width() / 2 - 5*text.length(), tft.height() / 2);

  bool pongRunning = true;

  while(pongRunning)
  {
    if (!gameStarted) 
    {
      // check that both players are ready

      // Check if player 1 is ready
      if (!player1Ready && (digitalRead(PLAYER1_UP) == HIGH || digitalRead(PLAYER1_DOWN) == HIGH)) 
      {
        tft.fillScreen(TFT_BLACK);
        player1Ready = true;
        String text = "Player 1 is ready";
        tft.drawString(text,tft.width() / 2 - 5*text.length(),tft.height() / 3);
      }

      // Check if player 2 is ready
      if (!player2Ready && (!digitalRead(PLAYER2_UP) == HIGH || !digitalRead(PLAYER2_DOWN) == HIGH)) 
      {
        player2Ready = true;
        String text = "Player 2 is ready";
        tft.drawString(text,tft.width() / 2 - 5*text.length(),2*tft.height() / 3);
      }

      // wait half a second to look nice
      delay(500);
      
      // If both players are ready, start a countdown
      if (player1Ready && player2Ready) 
      {
        for (int i = 3; i > 0; i--) 
        {
          tft.fillScreen(TFT_BLACK);
          tft.drawString(String(i),tft.width() / 2, tft.height() / 2);
          delay(1000);  // 1 second delay for countdown
        }

        tft.fillScreen(TFT_BLACK);  // Clear the screen after countdown
        gameStarted = true;
      }
    } 
    else 
    {
      tft.fillScreen(TFT_BLACK);

      // Draw paddles
      tft.fillRect(10, player1Y, PADDLE_WIDTH, PADDLE_HEIGHT, TFT_WHITE);
      tft.fillRect(tft.width() - 20, player2Y, PADDLE_WIDTH, PADDLE_HEIGHT, TFT_WHITE);

      // Draw ball
      tft.fillRect(ballX, ballY, BALL_SIZE, BALL_SIZE, TFT_WHITE);

      // Draw scores
      tft.drawString(String(player1Score), tft.width() / 3, 10);
      tft.drawString(String(player2Score), 2*tft.width() / 3, 10);

      // Player 1 controls
      if (digitalRead(PLAYER1_UP) == HIGH && player1Y > 0) 
      {
        player1Y -= PADDLE_SPEED;
      }
      if (digitalRead(PLAYER1_DOWN) == HIGH && player1Y < tft.height() - PADDLE_HEIGHT) 
      {
        player1Y += PADDLE_SPEED;
      }

      // Player 2 controls
      if (!digitalRead(PLAYER2_UP) == HIGH && player2Y > 0) 
      {
        player2Y -= PADDLE_SPEED;
      }
      if (!digitalRead(PLAYER2_DOWN) == HIGH && player2Y < tft.height() - PADDLE_HEIGHT) 
      {
        player2Y += PADDLE_SPEED;
      }

      // Update ball position and speed
      
      // Move ball
      ballX += ballDirX;
      ballY += ballDirY;

      // Increase ball speed as the game goes on, until maximum speed is reached
      if (currentBallSpeed < MAX_BALL_SPEED) 
      {
        currentBallSpeed += BALL_SPEED_INCREMENT / 100;
      }

      // If ball collides with the ceiling or floor then flip direction
      if (ballY <= 0 || ballY >= tft.height() - BALL_SIZE) 
      {
        ballDirY = -ballDirY;
      }

      // If it hits player 1s paddle, then flip x direciton
      if (ballX <= 20 && ballX >= 10 && ballY + BALL_SIZE >= player1Y && ballY <= player1Y + PADDLE_HEIGHT) 
      {
        ballDirX = currentBallSpeed;
        ballDirY = (ballY - (player1Y + PADDLE_HEIGHT / 2)) / 4;  // Add some angle to the bounce
      }

        // If it hits player 2s paddle, then flip x direciton
      if (ballX >= tft.width() - 30 && ballX <= tft.width() - 20 && ballY + BALL_SIZE >= player2Y && ballY <= player2Y + PADDLE_HEIGHT) 
      {
        ballDirX = -currentBallSpeed;
        ballDirY = (ballY - (player2Y + PADDLE_HEIGHT / 2)) / 4;  // Add some angle to the bounce
      }

      // IF ball goes behind the paddles then a score happened. Reset the ball after
      if (ballX < 10) 
      {
        player2Score++;
        
        //reset ball

        ballX = tft.width() / 2;
        ballY = tft.height() / 2;
        currentBallSpeed = INITIAL_BALL_SPEED;

        // Start the ball in a random direction
        if(random(0,2) == 0)
        {
          ballDirX = -INITIAL_BALL_SPEED;
        }
        else
        {
          ballDirX = INITIAL_BALL_SPEED;
        }
        ballDirY = INITIAL_BALL_SPEED;
      }
      if (ballX > tft.width() - 10) 
      {
        player1Score++;
        
        //reset ball

        ballX = tft.width() / 2;
        ballY = tft.height() / 2;
        currentBallSpeed = INITIAL_BALL_SPEED;

        // Start the ball in a random direction
        if(random(0,2) == 0)
        {
          ballDirX = -INITIAL_BALL_SPEED;
        }
        else
        {
          ballDirX = INITIAL_BALL_SPEED;
        }
        ballDirY = INITIAL_BALL_SPEED;
      }

      delay(20); // Frame rate control
    }
  }

}
void runTetris()
{

    tetrisSetup();

    bool tetrisRunning = true;

    while(tetrisRunning)
    {
      tetrisLoop();
    }

}

// TETRIS FUNCTIONS
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// Function to set up the screen for play
void screenInitialise(void)
{
  // The background colour
  tft.fillScreen(TFT_BLACK);  

  // The border lines
  tft.drawLine(11,19,122,19,GREY);
  tft.drawLine(11,19,11,240,GREY);
  tft.drawLine(122,19,122,240,GREY);
  tft.drawLine(11,240,122,240,GREY);
  
  // The score and level texts
  tft.drawString("SCORE:"+String(score),14,8,1);
  tft.drawString("LVL:"+String(lvl),88,8,1);

  // Make each block
  make_block( 0, TFT_BLACK);
  make_block( 1, RED);
  make_block( 2, PURPLE);
  make_block( 3, BLUE);
  make_block( 4, GREEN);
  make_block( 5, YELLOW);
  make_block( 6, LIGHT_GREEN);
  make_block( 7, PINK);


  // Start Position
  PutStartPos();

  // Initialise location of the first block
  for (int i = 0; i < 4; ++i) 
  {
    screen[pos.X + block.square[rot][i].X][pos.Y + block.square[rot][i].Y] = block.colour;
  }

  // Draw the blocks
  Draw();
}

void tetrisSetup(void) 
{
  
  pinMode(leftButton,INPUT_PULLUP);
  pinMode(rightButton,INPUT_PULLUP);
  pinMode(rotateButton,INPUT_PULLUP);
  pinMode(resetButton,INPUT_PULLUP);

  tft.init();
  tft.setRotation(0);
  tft.setSwapBytes(true);

  screenInitialise();
}
//========================================================================
void tetrisLoop() 
{
  if (gameover)
  { 
    if(digitalRead(leftButton)==0)
    {
      screenInitialise();

      for (int j = 0; j < Height; ++j)
      {
        for (int i = 0; i < Width; ++i)
        {
          screen[i][j] = 0;
        }
      }

      gameover=false;
      score=0;
      game_speed=20;
      lvl=1;

      PutStartPos();                             // Start Position
      for (int i = 0; i < 4; ++i) 
      {
        screen[pos.X + block.square[rot][i].X][pos.Y + block.square[rot][i].Y] = block.colour;
      }

      tft.drawString("SCORE:"+String(score),14,8,1);
      tft.drawString("LVL:"+String(lvl),88,8,1);
      Draw();  
    }

    else
    {
      if(resetted)
      {
        tft.fillScreen(TFT_BLACK);
        char *resetText = "PRESS BUTTON TO START GAME";

        // halfway point is at half the ttgo screen size - half the size of the text (to center text at center of ttgo)
        int xPosition = tft.width() / 2 - (strlen(resetText) / 2) * Length/2;
        tft.drawString(resetText, xPosition,180,1);

        resetted = false;
      }
    }

    return;
  }

  if(!gameover)
  {
    Point next_pos;
    int next_rot = rot;
    GetNextPosRot(&next_pos, &next_rot);
    ReviseScreen(next_pos, next_rot);
    delay(game_speed);                        // SPEED ADJUST
  }      

}
//========================================================================
void Draw()                                  // Draw 120x240 in the center
{                               
  for (int i = 0; i < Width; ++i) 
  {
    for (int j = 0; j < Height; ++j)
    {
      for (int k = 0; k < Length; ++k) 
      {
        for (int l = 0; l < Length; ++l)
        {
          backBuffer[j * Length + l][i * Length + k] = BlockImage[screen[i][j]][k][l];
        }
      }
    }
  }
  
  tft.pushImage(12, 20, 110, 220,*backBuffer);
}
//========================================================================
void PutStartPos() 
{
  game_speed=20;
  pos.X = 4; 
  pos.Y = 1;
  block = blocks[random(7)];
  rot = random(block.numRotate);
}
//========================================================================
bool GetSquares(Block block, Point pos, int rot, Point* squares) 
{
  bool overlap = false;
  for (int i = 0; i < 4; ++i) 
  {
    Point p;
    p.X = pos.X + block.square[rot][i].X;
    p.Y = pos.Y + block.square[rot][i].Y;
    // bitwise exclusive or
    overlap |= (p.X < 0 || p.X >= Width || p.Y < 0 || p.Y >= Height || screen[p.X][p.Y] != 0);
    squares[i] = p;
  }
  return !overlap;
}
//========================================================================
void GameOver() 
{
  for (int i = 0; i < Width; ++i) for (int j = 0; j < Height; ++j)
  {
    if (screen[i][j] != 0) 
    {
      screen[i][j] = 4;
    }
    gameover = true;
  }
 
}
//========================================================================
void ClearKeys() 
{ 
  but_ROTATE=false; 
  but_LEFT=false; 
  but_RIGHT=false; 
  but_RESET = false;
}
//========================================================================

void KeyPadLoop()
{
  // If the left button was pressed
  if(!digitalRead(leftButton))
  {
    // toggle so that you cant hold the button down
    if(!leftButtonPressed)
    {
      leftButtonPressed = true;
      ClearKeys();
      but_LEFT =true;
    }
  }
  // button not pressed
  else 
  {
    leftButtonPressed = false;
  }
  
  // If the right button was pressed
  if(!digitalRead(rightButton))
  {
    // toggle so that you cant hold the button down
    if(!rightButtonPressed)
    {
      rightButtonPressed = true;
      ClearKeys();
      but_RIGHT=true;
    }
  }
  // button not pressed
  else 
  {
    rightButtonPressed = false;
  }

  // If the rotate button was pressed
  if(!digitalRead(rotateButton))
  {
    // toggle so that you cant hold the button down
    if(!rotateButtonPressed)
    {
      rotateButtonPressed = true;
      ClearKeys();
      but_ROTATE =true;
    }
  }
  // button not pressed
  else 
  {
    rotateButtonPressed = false;
  }

  // If the reset button was pressed
  if(!digitalRead(resetButton))
  {
    // toggle so that you cant hold the button down
    if(!resetButtonPressed)
    {
        resetButtonPressed = true;
        ClearKeys();
        but_RESET =true;
    }
  }
  // button not pressed
  else 
  {
      resetButtonPressed = false;
  }
}
//========================================================================
void GetNextPosRot(Point* pnext_pos, int* pnext_rot) 
{
  KeyPadLoop();

  if (but_LEFT) 
  {
    started = true;
  }

  if (!started) 
  {
    return;
  }

  pnext_pos->X = pos.X;
  pnext_pos->Y = pos.Y;

  if ((fall_cnt = (fall_cnt + 1) % 10) == 0) 
  {
    pnext_pos->Y += 1;
  }
  else
  {
    if (but_LEFT) 
    { 
      but_LEFT = false; 
      pnext_pos->X -= 1;
    }
    else if (but_RIGHT) 
    { 
      but_RIGHT = false; 
      pnext_pos->X += 1;
    }
    else if (but_ROTATE) 
    { 
      but_ROTATE = false;
      *pnext_rot = (*pnext_rot + block.numRotate - 1) % block.numRotate; 
    }
    else if(but_RESET) 
    {
      but_RESET = false;
      resetted = true;
      GameOver();
      screenInitialise();
    }
  }
}
//========================================================================
void DeleteLine() 
{
  for (int j = 0; j < Height; ++j) 
  {
    bool Delete = true;
    for (int i = 0; i < Width; ++i) 
    {
      if (screen[i][j] == 0) 
      {
        Delete = false;
      }
    }

    if (Delete)
    {
      score++;
      if(score % 5 == 0)
      {
        lvl++;
        game_speed=game_speed-4;
        tft.drawString("LVL:"+String(lvl),88,8,1);
      }
      tft.drawString("SCORE:"+String(score),14,8,1);
      for (int k = j; k >= 1; --k) 
      {
        for (int i = 0; i < Width; ++i)
        {
          screen[i][k] = screen[i][k - 1];
        }
      }
    }
  }
}
//========================================================================
void ReviseScreen(Point next_pos, int next_rot) 
{
  if (!started) 
  {
    return;
  }

  Point next_squares[4];

  for (int i = 0; i < 4; ++i) 
  {
    screen[pos.X + block.square[rot][i].X][pos.Y + block.square[rot][i].Y] = 0;
  }

  if (GetSquares(block, next_pos, next_rot, next_squares)) 
  {

   for (int i = 0; i < 4; ++i)
   {
     screen[next_squares[i].X][next_squares[i].Y] = block.colour;
   }
   
   pos = next_pos; rot = next_rot;

  }
  else 
  {
    for (int i = 0; i < 4; ++i) 
    {
      screen[pos.X + block.square[rot][i].X][pos.Y + block.square[rot][i].Y] = block.colour;
    }

    if (next_pos.Y == pos.Y + 1) 
    {
      DeleteLine(); PutStartPos();
      if (!GetSquares(block, pos, rot, next_squares)) 
      {
        for (int i = 0; i < 4; ++i) 
        {
          screen[pos.X + block.square[rot][i].X][pos.Y + block.square[rot][i].Y] = block.colour;
        }

      GameOver();
      resetted = true;
      screenInitialise();
      }
    }
  }
  
  Draw();
}

//========================================================================
void make_block( int n , uint16_t colour )           // Make Block colour 
{                  
  for ( int i =0 ; i < 12; i++ ) 
  {
    for ( int j =0 ; j < 12; j++ )
    {
      BlockImage[n][i][j] = colour;                           // Block colour
      if ( i == 0 || j == 0 ) 
      {
        BlockImage[n][i][j] = 0;       // TFT_BLACK Line
      }
    } 
  }
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
